<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    
    <title>8. 模型安全：后门攻击 &#8212; 人工智能：数据与模型安全 1.0.0 documentation</title>

    <link rel="stylesheet" href="../_static/material-design-lite-1.3.0/material.purple-deep_orange.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx_materialdesign_theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/fontawesome/all.css" type="text/css" />
    <link rel="stylesheet" href="../_static/fonts.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/d2l.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/d2l.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="../_static/logo_removebg.png?"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="9. 模型安全：后门防御" href="chap9.html" />
    <link rel="prev" title="7. 模型安全：对抗防御" href="chap7.html" /> 
  </head>
<body>
    <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header mdl-layout--fixed-drawer"><header class="mdl-layout__header mdl-layout__header--waterfall ">
    <div class="mdl-layout__header-row">
        
        <nav class="mdl-navigation breadcrumb">
            <a class="mdl-navigation__link is-active"><span class="section-number">8. </span>模型安全：后门攻击</a>
        </nav>
        <div class="mdl-layout-spacer"></div>
        <nav class="mdl-navigation">
        
<form class="form-inline pull-sm-right" action="../search.html" method="get">
      <div class="mdl-textfield mdl-js-textfield mdl-textfield--expandable mdl-textfield--floating-label mdl-textfield--align-right">
        <label id="quick-search-icon" class="mdl-button mdl-js-button mdl-button--icon"  for="waterfall-exp">
          <i class="material-icons">search</i>
        </label>
        <div class="mdl-textfield__expandable-holder">
          <input class="mdl-textfield__input" type="text" name="q"  id="waterfall-exp" placeholder="Search" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </div>
      </div>
      <div class="mdl-tooltip" data-mdl-for="quick-search-icon">
      Quick search
      </div>
</form>
        
<a id="button-show-source"
    class="mdl-button mdl-js-button mdl-button--icon"
    href="../_sources/source/chap8.rst.txt" rel="nofollow">
  <i class="material-icons">code</i>
</a>
<div class="mdl-tooltip" data-mdl-for="button-show-source">
Show Source
</div>
        </nav>
    </div>
    <div class="mdl-layout__header-row header-links">
      <div class="mdl-layout-spacer"></div>
      <nav class="mdl-navigation">
          
              <a  class="mdl-navigation__link" href="https://ai-data-model-safety.github.io/">
                  <i class="fas fa-user-graduate"></i>
                  课程
              </a>
          
              <a  class="mdl-navigation__link" href="https://github.com/ai-data-model-safety">
                  <i class="fab fa-github"></i>
                  GitHub
              </a>
          
              <a  class="mdl-navigation__link" href="https://ai-data-model-safety.github.io/">
                  <i class="fas fa-external-link-alt"></i>
                  English
              </a>
      </nav>
    </div>
</header><header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="../index.html">
              <img class="logo" src="../_static/logo_with_text.png" alt="人工智能：数据与模型安全"/>
          </a>
      </span>
    
    
      <div class="globaltoc">
        <span class="mdl-layout-title toc">Table Of Contents</span>
        
        
            
            <nav class="mdl-navigation">
                <ul>
<li class="toctree-l1"><a class="reference internal" href="%E5%89%8D%E8%A8%80.html">前言</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="chap1.html">1. 人工智能与安全概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap2.html">2. 机器学习基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap3.html">3. 人工智能安全基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap4.html">4. 数据安全：攻击</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap5.html">5. 数据安全：防御</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap6.html">6. 模型安全：对抗攻击</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap7.html">7. 模型安全：对抗防御</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">8. 模型安全：后门攻击</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap9.html">9. 模型安全：后门防御</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap10.html">10. 模型安全：窃取攻防</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap11.html">11. 未来展望</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../chapter_references/zreferences.html">参考文献</a></li>
</ul>

            </nav>
        
        </div>
    
</header>
        <main class="mdl-layout__content" tabIndex="0">

	<script type="text/javascript" src="../_static/sphinx_materialdesign_theme.js "></script>
    <header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="../index.html">
              <img class="logo" src="../_static/logo_with_text.png" alt="人工智能：数据与模型安全"/>
          </a>
      </span>
    
    
      <div class="globaltoc">
        <span class="mdl-layout-title toc">Table Of Contents</span>
        
        
            
            <nav class="mdl-navigation">
                <ul>
<li class="toctree-l1"><a class="reference internal" href="%E5%89%8D%E8%A8%80.html">前言</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="chap1.html">1. 人工智能与安全概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap2.html">2. 机器学习基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap3.html">3. 人工智能安全基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap4.html">4. 数据安全：攻击</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap5.html">5. 数据安全：防御</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap6.html">6. 模型安全：对抗攻击</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap7.html">7. 模型安全：对抗防御</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">8. 模型安全：后门攻击</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap9.html">9. 模型安全：后门防御</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap10.html">10. 模型安全：窃取攻防</a></li>
<li class="toctree-l1"><a class="reference internal" href="chap11.html">11. 未来展望</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../chapter_references/zreferences.html">参考文献</a></li>
</ul>

            </nav>
        
        </div>
    
</header>

    <div class="document">
        <div class="page-content" role="main">
        
  <div class="section" id="chap-backdoor-attack">
<span id="id1"></span><h1><span class="section-number">8. </span>模型安全：后门攻击<a class="headerlink" href="#chap-backdoor-attack" title="Permalink to this heading">¶</a></h1>
<p>后门攻击与对抗攻击不同，是一种训练阶段的攻击，攻击者在训练开始前或者训练过程中通过某种方式往目标模型中安插后门触发器，从而可以在测试阶段精准的控制模型的预测结果。随着<strong>机器学习即服务</strong>（Machine
Learning as a Service, MLaaS）和<strong>模型即服务</strong>（Model as a Service,
MaaS）的流行以及训练大模型对网络数据的依赖，后门攻击已经成为继对抗攻击之后第二大模型安全威胁。</p>
<p>后门攻击的目标是：（1）后门模型在干净测试样本上具有正常的准确率；（2）当且仅当测试样本中包含预先设定的后门触发器时，后门模型才会产生由攻击者预先指定的预测结果。其中，目标（1）保证了后门攻击的隐蔽性，目标（2）保证了后门模型能够被攻击者任意操纵。</p>
<p>后门攻击通过两个操作来完成：<strong>后门植入</strong>和<strong>后门激活</strong>。后门植入是指在训练阶段，攻击者将预先定义的后门触发器植入目标模型中，从而获得一个<strong>后门模型</strong>。后门激活是指在推理阶段，任何包含后门触发器的测试样本都会激活后门，并控制模型输出攻击者指定的预测结果。后门攻击往往具备<em>低攻击门槛</em>、<em>高攻击成功率</em>、<em>高隐蔽性</em>等特点。一方面，这是因为后门触发器一旦被注入目标模型则很容易被用来发起攻击。另一方面，后门模型在干净样本上表现正常，当且仅当后门触发器出现时模型才会产生恶意行为，这使后门攻击很难通过普通的模型测试发现。</p>
<p>通常认为，后门攻击是一种<em>特殊的数据投毒攻击</em>，虽然后门攻击的实现方式并不局限于数据投毒（也可以直接修改模型参数）。传统数据投毒攻击的目标是降低模型的泛化性能，而后门攻击的目标是通过后门触发器控制模型的预测结果。换言之，后门攻击是一种有目标攻击、操纵型攻击，它的目标是通过触发器控制模型输出某个特定的、对攻击者有利的类别。
值得一提的是，后门攻击领域的开山之作BadNets <span id="id2">(<a class="reference internal" href="../chapter_references/zreferences.html#id223" title="Gu, T., Dolan-Gavitt, B., &amp; Garg, S. (2017). Badnets: identifying vulnerabilities in the machine learning model supply chain. arXiv preprint arXiv:1708.06733.">Gu <em>et al.</em>, 2017</a>)</span>
极大的推动了后门研究的发展，但其在2017年被提出之后并未引起足够的重视，而是在沉寂多年后才出现了大量跟进研究。经过短短几年，现在后门攻防研究已经发展成为一个重要的人工智能安全研究子领域。</p>
<p>一般而言，根据训练阶段是否需要修改<strong>后门样本</strong>（我们称添加了触发器图案的毒化样本为“后门样本”）对应的标签，后门攻击可分为<strong>脏标签攻击</strong>（dirty-label
attack）和<strong>净标签攻击</strong>（clean-label
attack）两大类。相较于脏标签攻击，净标签攻击不需要改变后门样本的标签，是一种更加隐蔽的攻击方法。从攻击方式来说，后门攻击可大致分为输入空间攻击、模型空间攻击、特征空间攻击、迁移学习攻击、联邦学习攻击、物理世界攻击等。后续章节将围绕后门攻击的不同攻击方式和应用场景对领域内一些经典工作进行介绍。</p>
<div class="section" id="sec-input-space-backdoor">
<span id="id3"></span><h2><span class="section-number">8.1. </span>输入空间攻击<a class="headerlink" href="#sec-input-space-backdoor" title="Permalink to this heading">¶</a></h2>
<p><strong>BadNets攻击。</strong> Gu等人 <span id="id4">(<a class="reference internal" href="../chapter_references/zreferences.html#id223" title="Gu, T., Dolan-Gavitt, B., &amp; Garg, S. (2017). Badnets: identifying vulnerabilities in the machine learning model supply chain. arXiv preprint arXiv:1708.06733.">Gu <em>et al.</em>, 2017</a>)</span>
最先研究了当前机器学习范式和训练流程中可能存在的后门漏洞，提出BadNets攻击算法在训练过程中向深度学习模型中安插后门。BadNets是一种经典的<em>脏标签攻击</em>方法，该攻击探索了<em>训练任务外包</em>和<em>预训练模型</em>两种威胁场景。考虑到深度神经网络的训练往往需要大量的训练数据，且对计算资源具有较高的需求，普通用户通常难以同时满足上述要求。因此，部分模型开发人员可能选择将训练任务外包给第三方平台，或者直接在公开预训练模型上进行下游任务微调。在此情况下，攻击者可能在第三方平台训练过程中为模型植入后门；同时，恶意攻击者也可能将包含后门的模型上传至公开平台，如GitHub，以供受害者下载使用。上述两种场景均为后门攻击的成功实施提供了条件。值得注意的是，基于数据投毒的后门攻击一般假设攻击者只能向训练数据中注入少部分后门样本，但是不能控制模型的训练过程，这里BadNets的威胁模型相对宽松一些，攻击者既可以接触到训练数据又可以控制模型训练。</p>
<div class="figure align-default" id="id58">
<span id="badnets-overview"></span><a class="reference internal image-reference" href="../_images/8.1_BadNets.png"><img alt="../_images/8.1_BadNets.png" src="../_images/8.1_BadNets.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">图8.1.1 </span><span class="caption-text">BadNets攻击的一般流程 <span id="id5">(<a class="reference internal" href="../chapter_references/zreferences.html#id223" title="Gu, T., Dolan-Gavitt, B., &amp; Garg, S. (2017). Badnets: identifying vulnerabilities in the machine learning model supply chain. arXiv preprint arXiv:1708.06733.">Gu <em>et al.</em>, 2017</a>)</span></span><a class="headerlink" href="#id58" title="Permalink to this image">¶</a></p>
</div>
<p>图 <a class="reference internal" href="#badnets-overview"><span class="std std-ref">BadNets攻击的一般流程 2017BadNets</span></a>
展示了BadNets攻击的一般流程。具体实施策略如下：给定训练集<span class="math notranslate nohighlight">\(D_{\text{train}}\)</span>，从<span class="math notranslate nohighlight">\(D_{\text{train}}\)</span>中按一定比例<span class="math notranslate nohighlight">\(p\)</span>随机抽取样本，插入后门触发器并修改其原始标签为攻击目标标签<span class="math notranslate nohighlight">\(y_{t}\)</span>，得到后门数据集<span class="math notranslate nohighlight">\(D_{\text{poison}}\)</span>。被毒化的训练数据集可表示为<span class="math notranslate nohighlight">\(\hat{D}_{\text{train}}=D_{\text{clean}} \cup D_{\text{poison}}\)</span>，其中<span class="math notranslate nohighlight">\(D_{\text{clean}}\)</span>表示干净部分数据，<span class="math notranslate nohighlight">\(D_{\text{poison}}\)</span>表示毒化部分数据。在<span class="math notranslate nohighlight">\(\hat{D}_{\text{train}}\)</span>上训练得到的模型即为后门模型。图
<a class="reference internal" href="#badnets-overview"><span class="std std-ref">BadNets攻击的一般流程 2017BadNets</span></a>
展示了简单的后门触发器图案：单像素点和白方块。为了满足隐蔽性，这些触发器往往被添加在输入图像的特定区域（如图像右下角）。对图像分类任务来说，在毒化数据集上训练后门模型的过程可定义如下：</p>
<div class="math notranslate nohighlight" id="equation-source-chap8-0">
<span class="eqno">(8.1.1)<a class="headerlink" href="#equation-source-chap8-0" title="Permalink to this equation">¶</a></span>\[\min_{\theta} \mathbb{E}_{( x, y) \sim \hat{D}_{\text{train}}}\left[\mathcal{L}_{\text{CE}}\left(f_{\theta}( x), y\right)\right].\]</div>
<p>值得注意的是，上述公式给出了后门攻击的一般性优化目标。后续的相关工作大都遵循这一原则，只是在触发器的设计上做不同的改进和提升。另一方面，BadNets攻击主要围绕模型外包和预训练模型场景，这使得此类后门攻击可以影响不同的数据集和模型结构，且不需要很高的投毒率。举例来说，BadNets后门攻击在CIFAR-10数据集上能够以10%以下的投毒率达到99%以上的攻击成功率（当然就现在的研究来说，10%的投毒率已经是很高了）。</p>
<p><strong>Blend攻击。</strong> Chen等人 <span id="id6">(<a class="reference internal" href="../chapter_references/zreferences.html#id57" title="Chen, X., Liu, C., Li, B., Lu, K., &amp; Song, D. (2017). Targeted backdoor attacks on deep learning systems using data poisoning. arXiv preprint arXiv:1712.05526.">Chen <em>et al.</em>, 2017</a>)</span>
在BadNets攻击的基础上进行了新颖的触发器设计和改进，提出了Blend攻击。Blend攻击使用的两种新颖的触发器为：<strong>全局随机噪声</strong>和<strong>图像混合策略</strong>。这种攻击的提出，使得后门触发器不再只局限于图像的特定区域（在BadNets攻击中触发器固定在图像的右下角）。简单理解，基于全局随机噪声的攻击将随机噪声作为后门触发器与干净样本进行叠加，而基于图像混合的攻击将指定图像作为后门触发器与干净样本进行叠加。需要注意的是，作为一种<em>脏标签攻击</em>，Blend攻击在添加完后门触发器后也需要将图像的标签修改为后门标签。</p>
<div class="figure align-default" id="id59">
<span id="fig-blend-rand"></span><a class="reference internal image-reference" href="../_images/8.2_blend_rand.png"><img alt="../_images/8.2_blend_rand.png" src="../_images/8.2_blend_rand.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">图8.1.2 </span><span class="caption-text">随机噪声后门攻击 <span id="id7">(<a class="reference internal" href="../chapter_references/zreferences.html#id57" title="Chen, X., Liu, C., Li, B., Lu, K., &amp; Song, D. (2017). Targeted backdoor attacks on deep learning systems using data poisoning. arXiv preprint arXiv:1712.05526.">Chen <em>et al.</em>, 2017</a>)</span></span><a class="headerlink" href="#id59" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-default" id="id60">
<span id="fig-blend-background"></span><a class="reference internal image-reference" href="../_images/8.3_blend_background.png"><img alt="../_images/8.3_blend_background.png" src="../_images/8.3_blend_background.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">图8.1.3 </span><span class="caption-text">图像融合后门攻击 <span id="id8">(<a class="reference internal" href="../chapter_references/zreferences.html#id57" title="Chen, X., Liu, C., Li, B., Lu, K., &amp; Song, D. (2017). Targeted backdoor attacks on deep learning systems using data poisoning. arXiv preprint arXiv:1712.05526.">Chen <em>et al.</em>, 2017</a>)</span></span><a class="headerlink" href="#id60" title="Permalink to this image">¶</a></p>
</div>
<p>基于全局随机噪声的后门攻击流程为：假定单个干净样本为<span class="math notranslate nohighlight">\(x\)</span>，其原始标签为<span class="math notranslate nohighlight">\(y\)</span>，目标后门标签为<span class="math notranslate nohighlight">\(y_{t}\)</span>，攻击的目标是使得后门模型将属于<span class="math notranslate nohighlight">\(y\)</span>的样本预测为<span class="math notranslate nohighlight">\(y_{t}\)</span>。具体策略为，定义一组干净样本<span class="math notranslate nohighlight">\(\sum( x)\)</span>，对其中输入<span class="math notranslate nohighlight">\(x\)</span>施加噪声<span class="math notranslate nohighlight">\(\delta\)</span>以便生成后门样本：</p>
<div class="math notranslate nohighlight" id="equation-source-chap8-1">
<span class="eqno">(8.1.2)<a class="headerlink" href="#equation-source-chap8-1" title="Permalink to this equation">¶</a></span>\[\sum\nolimits^{rand}( x)=\{\text{Clip}( x+ \delta)| \delta \in [-5, 5]^{H×W×3}\}\]</div>
<p>其中，<span class="math notranslate nohighlight">\(x\)</span>为输入的干净样本，<span class="math notranslate nohighlight">\(H\)</span>和<span class="math notranslate nohighlight">\(W\)</span>分别为高和宽，<span class="math notranslate nohighlight">\(\text{Clip}(\cdot)\)</span>函数将<span class="math notranslate nohighlight">\(x\)</span>限制到有效像素值范围内，即<span class="math notranslate nohighlight">\([0, 255]\)</span>。如图
<a class="reference internal" href="#fig-blend-rand"><span class="std std-ref">随机噪声后门攻击 chen2017targeted</span></a>
所示，攻击者利用<span class="math notranslate nohighlight">\(\sum( x)\)</span>对<span class="math notranslate nohighlight">\(x\)</span>随机加入细微的噪声生成一组后门样本<span class="math notranslate nohighlight">\(x_{\text{poison}_1}, x_{\text{poison}_2},..., x_{\text{poison}_N}\)</span>，同时将生成的样本类别重新标注为<span class="math notranslate nohighlight">\(y_{t}\)</span>并加入训练集。在该训练集上训练得到的后门模型会在测试阶段将任意后门样本<span class="math notranslate nohighlight">\(x_{\text{poison}}\)</span>预测为类别<span class="math notranslate nohighlight">\(y_{t}\)</span>，以达到攻击目标。实验表明，这种攻击在较低的后门注入率下（比如5%）也能够达到将近100%的攻击成功率。</p>
<p>基于图像混合的后门攻击与上述基于全局噪声的攻击类似，不过后门触发器由随机噪声变成了某个特定的图像。具体的，假定后门触发背景图像为<span class="math notranslate nohighlight">\(k\)</span>，攻击者将触发器与部分干净训练样本按特定比例<span class="math notranslate nohighlight">\(p\)</span>融合构成后门样本，同时修改标签为<span class="math notranslate nohighlight">\(y_{t}\)</span>并加入训练集。具体定义如下：</p>
<div class="math notranslate nohighlight" id="equation-source-chap8-2">
<span class="eqno">(8.1.3)<a class="headerlink" href="#equation-source-chap8-2" title="Permalink to this equation">¶</a></span>\[\prod\nolimits_\alpha^{blend}(k, x)=\alpha\cdot k+(1-\alpha)\cdot  x,\]</div>
<p>其中，<span class="math notranslate nohighlight">\(x\)</span>为训练集中随机采样的要与触发器背景图像<span class="math notranslate nohighlight">\(k\)</span>融合的样本，<span class="math notranslate nohighlight">\(\alpha\in [0,1]\)</span>为控制融合的参数。当<span class="math notranslate nohighlight">\(\alpha\)</span>较小时，插入的触发器背景不易被人眼所察觉，具有较强的隐蔽性。上述的融合和覆盖策略保留了原始图片的部分像素，并将需要覆盖的像素值设置为背景图<span class="math notranslate nohighlight">\(k\)</span>与原始像素的融合值，如图
<a class="reference internal" href="#fig-blend-background"><span class="std std-ref">图像融合后门攻击 chen2017targeted</span></a>
所示。在通过这些策略生成一组后门样本后，将其标注为目标类别<span class="math notranslate nohighlight">\(y_{t}\)</span>并加入训练集。在该训练集上训练得到的模型会在测试时把任何融入了背景图<span class="math notranslate nohighlight">\(y_{t}\)</span>的样本预测为类别<span class="math notranslate nohighlight">\(y_{t}\)</span>，。</p>
<p>至此，我们介绍了后门领域两种经典的脏标签攻击算法：BadNets攻击和Blend攻击。在接下来的章节中，我们将介绍一类更隐蔽的后门攻击方法：净标签攻击，此类方法在不修改标签的情况下依然可以达到很高的攻击成功率。</p>
<p><strong>净标签攻击。</strong>
脏标签后门攻击的主要缺点是攻击者需要修改后门样本的标签为攻击者指定的<em>后门标签</em>，这使得后门样本容易通过简单的<em>错误标签统计</em>检测出来。净标签攻击只添加触发器不修改标签，可以避免修改标签所带来的隐蔽性下降。由于净标签攻击不修改标签，所以为了实现有效攻击就必须在后门类别的样本上添加触发器。举例来说，假设攻击者的攻击目标是第0类，那么净标签攻击只能对第0类的数据进行投毒，而非其他类别，这样才能在不改变标签的情况下又能影响模型的功能。此外，净标签攻击也往往需要额外的触发器增强手段来提升触发器在正确标注情况下的攻击强度。</p>
<p>Turner等人 <span id="id9">(<a class="reference internal" href="../chapter_references/zreferences.html#id61" title="Turner, A., Tsipras, D., &amp; Madry, A. (2018). Clean-label backdoor attacks.">Turner <em>et al.</em>, 2018</a>)</span>
首次提出<strong>净标签后门攻击</strong>（clean-label backdoor
attack）。该方法的主要思路为，通过特定操作使待毒化样本的原始特征变得模糊或受到破坏，让模型无法从这些样本中获取有用的信息，转而去关注后门触发器特征。对原始图像的干扰操作可以分为两种：<em>基于生成模型的插值</em>与<em>对抗扰动</em>。生成模型诸如对抗生成网络（GAN）
<span id="id10">(<a class="reference internal" href="../chapter_references/zreferences.html#id248" title="Goodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B., Warde-Farley, D., Ozair, S., … Bengio, Y. (2014). Generative adversarial nets. Advances in Neural Information Processing Systems, 27.">Goodfellow <em>et al.</em>, 2014</a>)</span> 或者变分自编码器（variational
autoencoder，VAE） <span id="id11">(<a class="reference internal" href="../chapter_references/zreferences.html#id249" title="Kingma, D. P., &amp; Welling, M. (2013). Auto-encoding variational bayes. arXiv preprint arXiv:1312.6114.">Kingma and Welling, 2013</a>)</span>
可以通过<strong>插值</strong>的方式改变生成数据的分布。攻击者可以利用生成模型的这一特点来将目标类别的样本转换为任意非目标类别的样本，这些样本所具有的原始特征被模糊化。在训练时，模型为了正确分类这些<em>插值样本</em>，则会去关注其他一些特征，比如后门触发器。</p>
<p>给定生成器<span class="math notranslate nohighlight">\(G:\mathbb{R}^d\longrightarrow \mathbb{R}^n\)</span>，基于输入随机向量<span class="math notranslate nohighlight">\(z\in \mathbb{R}^d\)</span>生成维度为<span class="math notranslate nohighlight">\(n\)</span>的图像<span class="math notranslate nohighlight">\(G( z)\)</span>。那么，对于目标图像<span class="math notranslate nohighlight">\(x\in \mathbb{R}^n\)</span>，定义编码函数为：</p>
<div class="math notranslate nohighlight" id="equation-source-chap8-3">
<span class="eqno">(8.1.4)<a class="headerlink" href="#equation-source-chap8-3" title="Permalink to this equation">¶</a></span>\[E_G( x)=\mathop{\mathrm{arg\,min}}\limits_{ z\in \mathbb{R}^d}\| x-G( z)\|_2.\]</div>
<p>基于此编码函数，对于给定插值常数<span class="math notranslate nohighlight">\(\tau\)</span>，定义插值函数为：</p>
<div class="math notranslate nohighlight" id="equation-source-chap8-4">
<span class="eqno">(8.1.5)<a class="headerlink" href="#equation-source-chap8-4" title="Permalink to this equation">¶</a></span>\[I_G( x_1, x_2,\tau)=G(\tau  z_1+(1-\tau) z_2),\; \text{where} \;  z_1=E_G( x_1), z_2=E_G( x_2),\]</div>
<p>其中，<span class="math notranslate nohighlight">\(x_1\)</span>与<span class="math notranslate nohighlight">\(x_2\)</span>分别为目标类别样本与任意非目标类别样本，<span class="math notranslate nohighlight">\(I_G\)</span>先将二者投影到编码空间得到向量<span class="math notranslate nohighlight">\(z_1\)</span>与<span class="math notranslate nohighlight">\(z_2\)</span>，随后通过插值常数<span class="math notranslate nohighlight">\(\tau\)</span>对<span class="math notranslate nohighlight">\(z_1\)</span>和<span class="math notranslate nohighlight">\(z_2\)</span>进行插值操作，最后再将得到的向量还原到输入空间，得到插值图像<span class="math notranslate nohighlight">\(x_{\text{GAN}}\)</span>。</p>
<p>另一种触发器增强策略是利用对抗扰动来阻止模型对原始特征的学习。如前文所述，在干净标签的设定下，后门触发器只能安插于目标类别的部分样本中，模型可能会只捕捉到干净特征而忽略了后门触发器。考虑到对抗噪声可以以高置信度误导模型，因此可以使用对抗噪声干扰模型的注意力，通过破坏干净特征使模型更容易捕获后门特征（如图
<a class="reference internal" href="#fig-clean-label-adv"><span class="std std-ref">对干净图像进行对抗扰动 turner2018clean</span></a>
所示）。对于给定输入<span class="math notranslate nohighlight">\(x\)</span>的对抗扰动操作定义如下：</p>
<div class="math notranslate nohighlight" id="equation-source-chap8-5">
<span class="eqno">(8.1.6)<a class="headerlink" href="#equation-source-chap8-5" title="Permalink to this equation">¶</a></span>\[x_{\text{adv}}=\mathop{\mathrm{arg\,max}}\limits_{\| x'- x\|_p\leq \epsilon}\mathcal{L}_{\text{adv}}(f( x'),y),\]</div>
<p>其中，<span class="math notranslate nohighlight">\(\epsilon\)</span>为对抗扰动的上界，<span class="math notranslate nohighlight">\(x\)</span>和<span class="math notranslate nohighlight">\(y\)</span>分别为原始样本和其标签。这里采用PGD攻击算法
<span id="id12">(<a class="reference internal" href="../chapter_references/zreferences.html#id143" title="Madry, A., Makelov, A., Schmidt, L., Tsipras, D., &amp; Vladu, A. (2018). Towards deep learning models resistant to adversarial attacks. International Conference on Learning Representations.">Madry <em>et al.</em>, 2018</a>)</span>
来生成对抗扰动，用来生成扰动的模型可以是独立对抗训练的鲁棒模型。</p>
<div class="figure align-default" id="id61">
<span id="fig-clean-label-adv"></span><a class="reference internal image-reference" href="../_images/8.4_clean_label_adv.png"><img alt="../_images/8.4_clean_label_adv.png" src="../_images/8.4_clean_label_adv.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">图8.1.4 </span><span class="caption-text">对干净图像进行对抗扰动 <span id="id13">(<a class="reference internal" href="../chapter_references/zreferences.html#id61" title="Turner, A., Tsipras, D., &amp; Madry, A. (2018). Clean-label backdoor attacks.">Turner <em>et al.</em>, 2018</a>)</span></span><a class="headerlink" href="#id61" title="Permalink to this image">¶</a></p>
</div>
<p>上述两种方法都可以有效提高净标签后门攻击的成功率，二者中对抗扰动的增强效果更好。
此外，提高插值常数<span class="math notranslate nohighlight">\(\tau\)</span>与对抗扰动上界<span class="math notranslate nohighlight">\(\epsilon\)</span>都可以对干净特征产生更大的干扰，进而提高后门攻击成功率，但是增加插值和扰动会降低后门样本的隐蔽性。因此，在实际应用中，攻击者需要在攻击成功率与隐蔽性之间进行权衡。</p>
<p><strong>输入感知攻击。</strong>早期的后门攻击方法大都对整个数据集设计一个单一的触发器样式（trigger
pattern），然后向要投毒的样本中添加相同的触发器图案，并没有区分样本间的差异。Nguyen等人~
<span id="id14">(<a class="reference internal" href="../chapter_references/zreferences.html#id466" title="Nguyen, T. A., &amp; Tran, A. (2020). Input-aware dynamic backdoor attack. Advances in Neural Information Processing Systems, 33, 3454–3464.">Nguyen and Tran, 2020</a>)</span>
提出一种更加先进的<strong>输入感知动态后门攻击</strong>（input-aware dynamic
backdoor
attack，Dynamic），也称为动态后门攻击。与早期后门攻击方法不同，输入感知攻击的触发器随输入样本而改变，即每个投毒样本都添加不同的触发器样式。输入感知攻击打破了触发器“输入无关”的传统假设，构建了触发器与输入相关的新型攻击方法。更重要的是，输入感知攻击的提出在一定程度上推进了后门防御工作的发展，具体细节将会在后门防御章节介绍。</p>
<div class="figure align-default" id="id62">
<span id="fig-dynamic"></span><a class="reference internal image-reference" href="../_images/8.5_Dynamic.png"><img alt="../_images/8.5_Dynamic.png" src="../_images/8.5_Dynamic.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">图8.1.5 </span><span class="caption-text">输入感知攻击 <span id="id15">(<a class="reference internal" href="../chapter_references/zreferences.html#id466" title="Nguyen, T. A., &amp; Tran, A. (2020). Input-aware dynamic backdoor attack. Advances in Neural Information Processing Systems, 33, 3454–3464.">Nguyen and Tran, 2020</a>)</span></span><a class="headerlink" href="#id62" title="Permalink to this image">¶</a></p>
</div>
<p>图 <a class="reference internal" href="#fig-dynamic"><span class="std std-numref">图8.1.5</span></a>
展示了输入感知攻击的一般流程。攻击者使用生成器<span class="math notranslate nohighlight">\(g\)</span>根据输入图像创建触发器<span class="math notranslate nohighlight">\((M, r)\)</span>（<span class="math notranslate nohighlight">\(M\)</span>图片掩码，<span class="math notranslate nohighlight">\(r\)</span>是触发器图案）。中毒的分类器可以正确地识别干净的输入(最左边和最右边的图像)，但在注入相应的触发器(第二和第四张图像)时返回预定义的标签(“飞机”)。<strong>触发器-输入</strong>是相互匹配的，向不匹配的干净图片中插入触发器并不会激活攻击(中间图像)。为了实现这一目标，研究者提出了<em>多损失驱动</em>的触发器生成器。该生成器采用了常规的<strong>编码器-解码器</strong>架构。假定训练模型为<span class="math notranslate nohighlight">\(f: \mathcal{X} \rightarrow \mathcal{C}\)</span>，其中<span class="math notranslate nohighlight">\(\mathcal{X}\)</span>是输入样本空间，<span class="math notranslate nohighlight">\(\mathcal{C}=\{c_{1}, c_{2}, \ldots, c_{m}\}\)</span>为<span class="math notranslate nohighlight">\(m\)</span>个输出类别空间。后门触发函数定义为<span class="math notranslate nohighlight">\(\mathcal{B}\)</span>，则在干净样本上添加后门触发器<span class="math notranslate nohighlight">\(t=(M, r)\)</span>定义为:</p>
<div class="math notranslate nohighlight" id="equation-source-chap8-6">
<span class="eqno">(8.1.7)<a class="headerlink" href="#equation-source-chap8-6" title="Permalink to this equation">¶</a></span>\[\mathcal{B}( x,t) =  x \odot (1-M) +  r \odot M\]</div>
<p>其中，<span class="math notranslate nohighlight">\(M\)</span>表示触发器的掩码，用来控制触发器的稀疏性；<span class="math notranslate nohighlight">\(r\)</span>代表生成的触发器图案。</p>
<p>输入感知攻击的损失函数由两部分组成：<strong>分类损失</strong>和<strong>多样性损失</strong>。分类损失采用交叉熵损失<span class="math notranslate nohighlight">\(\mathcal{L}_{\text{CE}}\)</span>，以一定概率<span class="math notranslate nohighlight">\(p\)</span>为训练数据添加后门触发器以实现后门注入。多样性损失<span class="math notranslate nohighlight">\(\mathcal{L}_{\text{div}}\)</span>鼓励生成器生成多样化的触发器样式，在形式上避免重复，满足触发器和样本之间的对应关系。上述两个损失通过加权和组成总损失函数：</p>
<div class="math notranslate nohighlight" id="equation-source-chap8-7">
<span class="eqno">(8.1.8)<a class="headerlink" href="#equation-source-chap8-7" title="Permalink to this equation">¶</a></span>\[\mathcal{L} = \mathcal{L}_{\text{CE}} + \lambda \mathcal{L}_{\text{div}}.\]</div>
<p>输入感知攻击在触发器和样本上实现了关联性耦合，提供了一种更灵活的触发器生成模式。但是，这样的后门触发器也存在缺点：一方面生成的触发器样式在视觉上是可察觉的，隐蔽性较差，容易被人工检测；另一方面，输入感知攻击仍然是一种脏标签攻击，需要修改后门样本的标签，这制约了其在现实场景中的威力。之后，Li等人
<span id="id16">(<a class="reference internal" href="../chapter_references/zreferences.html#id232" title="Li, Y., Li, Y., Wu, B., Li, L., He, R., &amp; Lyu, S. (2021). Invisible backdoor attack with sample-specific triggers. IEEE/CVF International Conference on Computer Vision (pp. 16463–16472).">Li <em>et al.</em>, 2021</a>)</span>
提出了一种基于编码器-解码器的<strong>图像隐写后门攻击</strong>方法
，该攻击的触发器也随输入样本的不同而变化。实验结果表明，该攻击能够在大规模图像数据（如ImageNet数据集）上取得较高的攻击性能。</p>
</div>
<div class="section" id="sec-model-space-backdoor">
<span id="id17"></span><h2><span class="section-number">8.2. </span>模型空间攻击<a class="headerlink" href="#sec-model-space-backdoor" title="Permalink to this heading">¶</a></h2>
<p>向模型中安插后门并不一定要以数据投毒的方式进行，还可以通过修改模型参数达到。<strong>模型空间攻击</strong>就是这样一类不依赖数据投毒的后门攻击。此类攻击利用<em>逆向工程</em>等技术，从预训练模型中生成后门触发器，并通过<em>微调</em>等形式将触发器植入模型。相较于输入空间后门攻击，模型空间后门攻击要求攻击者在不能访问原始训练数据的前提下，对给定模型实施后门攻击。下面介绍两个经典的模型空间后门攻击方法。</p>
<p><strong>木马攻击。</strong> Liu等人 <span id="id18">(<a class="reference internal" href="../chapter_references/zreferences.html#id58" title="Liu, Y., Ma, S., Aafer, Y., Lee, W.-C., Zhai, J., Wang, W., &amp; Zhang, X. (2018). Trojaning attack on neural networks. Network and Distributed Systems Security Symposium.">Liu <em>et al.</em>, 2018</a>)</span>
提出的<strong>特洛伊木马攻击</strong>（Trojan
attack），简称为木马攻击，是首个模型空间后门攻击方法。木马攻击的威胁模型很接近现实，因为在实际应用场景中，数据收集和模型训练等关键过程往往掌握在模型厂商的手里，这些过程需要耗费大量的资源，所以攻击者没有必要为了安插后门而花费高额的代价。但是，木马攻击允许攻击者直接对预训练完成的模型进行攻击，大大降低了攻击代价。
简单来说，木马攻击的目标是在训练数据不可知且不可用的前提下，对已经训练好的模型实施攻击。</p>
<p>木马攻击的流程如图 <a class="reference internal" href="#fig-trojan"><span class="std std-numref">图8.2.1</span></a>
所示，大致分为三步：木马样式生成、训练数据生成和木马植入。下面将分别介绍这三个步骤所使用的方法。</p>
<div class="figure align-default" id="id63">
<span id="fig-trojan"></span><a class="reference internal image-reference" href="../_images/8.6_Trojan.png"><img alt="../_images/8.6_Trojan.png" src="../_images/8.6_Trojan.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">图8.2.1 </span><span class="caption-text">木马攻击的基本流程 <span id="id19">(<a class="reference internal" href="../chapter_references/zreferences.html#id58" title="Liu, Y., Ma, S., Aafer, Y., Lee, W.-C., Zhai, J., Wang, W., &amp; Zhang, X. (2018). Trojaning attack on neural networks. Network and Distributed Systems Security Symposium.">Liu <em>et al.</em>, 2018</a>)</span></span><a class="headerlink" href="#id63" title="Permalink to this image">¶</a></p>
</div>
<p><strong>（1）木马样式生成</strong>：考虑到模型从输入中提取到的特征决定了其最终输出，因此所安插的木马需要与模型的关键神经元有很强的关联，才能改变模型的深度特征，进而导致误分类。因此，木马攻击选取模型某一层的一组特定神经元来生成后门触发器样式<span class="math notranslate nohighlight">\(r\)</span>。给定模型<span class="math notranslate nohighlight">\(f\)</span>在第<span class="math notranslate nohighlight">\(l\)</span>层的一组神经元与其对应的<strong>激活目标值</strong><span class="math notranslate nohighlight">\({(e_1, v_1), (e_2, v_2), \ldots }\)</span>，木马样式<span class="math notranslate nohighlight">\(r\)</span>可以通过最小化下面的损失函数进行优化：</p>
<div class="math notranslate nohighlight" id="equation-source-chap8-8">
<span class="eqno">(8.2.1)<a class="headerlink" href="#equation-source-chap8-8" title="Permalink to this equation">¶</a></span>\[\mathcal{L}_{\text{trj}}(f, r) = (v_1-f_{e_1})^2 + (v_2-f_{e_2})^2 + \ldots\]</div>
<p>其中，梯度为<span class="math notranslate nohighlight">\(\nabla=\frac{\partial \mathcal{L}_{\text{trj}}(f, r)}{\partial r}\)</span>，对<span class="math notranslate nohighlight">\(r\)</span>按一定步长<span class="math notranslate nohighlight">\(\eta\)</span>进行基于梯度下降的迭代更新<span class="math notranslate nohighlight">\(r= r−\eta\cdot \nabla\)</span>，直至收敛。最终得到的<span class="math notranslate nohighlight">\(r\)</span>即为生成的木马样式。上述优化过程在特定神经元与木马样式之间建立了强有力的关联，保证一旦出现对应的木马样式，这些神经元就会被显著激活，从而指向后门目标类别。</p>
<p><strong>（2）训练数据的生成</strong>：由于攻击者并没有对原始训练数据的访问权限，因此需要利用逆向工程来生成部分训练数据作为后门植入的媒介。逆向工程的目的是将一张与原始数据集无关的图像<span class="math notranslate nohighlight">\(x'\)</span>，转化为能够代表原始数据集中类别为<span class="math notranslate nohighlight">\(y_t\)</span>的样本。<span class="math notranslate nohighlight">\(x'\)</span>可以是从不相关的公共数据集中<em>随机抽取</em>的一张图像或者是对大量随机不相关图像进行平均得到的<em>平均图像</em>。为了模仿原始训练数据，需要更新输入<span class="math notranslate nohighlight">\(x'\)</span>使其能够产生与原始训练样本相同的激活值。假定分类层中类别<span class="math notranslate nohighlight">\(y_t\)</span>的输出神经元激活为<span class="math notranslate nohighlight">\(f_{y_t}\)</span>，输入<span class="math notranslate nohighlight">\(x'\)</span>对应的目标值为<span class="math notranslate nohighlight">\(v\)</span>，数据逆向的损失函数定义为：</p>
<div class="math notranslate nohighlight" id="equation-source-chap8-9">
<span class="eqno">(8.2.2)<a class="headerlink" href="#equation-source-chap8-9" title="Permalink to this equation">¶</a></span>\[\mathcal{L}_{\text{rvs}}(f,  x')=(v-f_{y_t}( x'))^2.\]</div>
<p>与木马样式的生成过程类似，数据逆向利用输入层的梯度信息<span class="math notranslate nohighlight">\(\nabla=\frac{\partial \mathcal{L}_{\text{rvs}}(f, x')}{\partial x'}\)</span>，对<span class="math notranslate nohighlight">\(x'\)</span>按一定步长<span class="math notranslate nohighlight">\(\eta\)</span>进行迭代更新<span class="math notranslate nohighlight">\(x'= x'−\eta\cdot \nabla\)</span>，直到收敛。最终得到的<span class="math notranslate nohighlight">\(x'\)</span>即可作为原始训练数据类别<span class="math notranslate nohighlight">\(y_t\)</span>的替代数据。值得注意的是，这一过程需要遍历模型的所有输出类别，得到所有类别的替代数据。</p>
<p><strong>（3）木马植入</strong>：在得到木马样式以及逆向数据集后，就可以对模型植入木马后门。具体而言，对逆向数据集中的样本<span class="math notranslate nohighlight">\(x'\)</span>添加木马触发器<span class="math notranslate nohighlight">\(r\)</span>，相应的，修改木马样本的标签为攻击目标类别<span class="math notranslate nohighlight">\(y_t\)</span>，得到包含“木马样本-后门标签”对<span class="math notranslate nohighlight">\(( x'+ r,y_t)\)</span>的木马数据集。在木马数据集上对干净模型进行微调，便可以将木马样式植入当前模型。微调可以在与木马生成相关的特定神经元所在层上进行，这样能极大的减少微调开销，同时保证攻击效果。</p>
<div class="figure align-default" id="id64">
<span id="fig-trojannet"></span><a class="reference internal image-reference" href="../_images/8.7_TrojanNet.png"><img alt="../_images/8.7_TrojanNet.png" src="../_images/8.7_TrojanNet.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">图8.2.2 </span><span class="caption-text">TrojanNet攻击（粉色和红色部分为木马模块）
<span id="id20">(<a class="reference internal" href="../chapter_references/zreferences.html#id59" title="Tang, R., Du, M., Liu, N., Yang, F., &amp; Hu, X. (2020). An embarrassingly simple approach for trojan attack in deep neural networks. ACM SIGKDD International Conference on Knowledge Discovery &amp; Data Mining (pp. 218–228).">Tang <em>et al.</em>, 2020</a>)</span></span><a class="headerlink" href="#id64" title="Permalink to this image">¶</a></p>
</div>
<p><strong>TrojanNet攻击。</strong>
后门攻击还可以直接对目标模型的结构进行调整，构建具有木马功能的模块，然后拼接到目标模型上去。此类攻击的思想跟输入空间攻击有一定的相似性，输入空间攻击通过数据投毒在干净数据的基础上增加额外的毒化数据，而结构攻击则是在干净模型的基础上增加额外的木马模块。此类方法的一个代表性工作是Tang等人~
<span id="id21">(<a class="reference internal" href="../chapter_references/zreferences.html#id59" title="Tang, R., Du, M., Liu, N., Yang, F., &amp; Hu, X. (2020). An embarrassingly simple approach for trojan attack in deep neural networks. ACM SIGKDD International Conference on Knowledge Discovery &amp; Data Mining (pp. 218–228).">Tang <em>et al.</em>, 2020</a>)</span>
提出的<strong>TrojanNet攻击</strong>。TrojanNet的攻击流程如图
<a class="reference internal" href="#fig-trojannet"><span class="std std-numref">图8.2.2</span></a> 所示，大致分为以下3个步骤：</p>
<p><strong>（1）构造木马模块</strong>：攻击者需要事先定义<strong>木马数据</strong>，通常木马触发器为4×4大小的二值化像素块。然后，定义一个多层感知机模块<span class="math notranslate nohighlight">\(m\)</span>，并在预先定义的木马数据上对<span class="math notranslate nohighlight">\(m\)</span>进行训练，得到木马模块<span class="math notranslate nohighlight">\(m_t\)</span>。为了保证木马模块<span class="math notranslate nohighlight">\(m_t\)</span>能够与目标模型架构匹配，需要根据目标模型的输出维度来调整木马模块的输出维度。</p>
<p><strong>（2）木马模块与目标模型拼接</strong>：可以采用加权求和的方式对目标模型输出结果<span class="math notranslate nohighlight">\(y_{c}\)</span>和木马模块的输出结果<span class="math notranslate nohighlight">\(y_{t}\)</span>进行融合，定义如下：</p>
<div class="math notranslate nohighlight" id="equation-source-chap8-10">
<span class="eqno">(8.2.3)<a class="headerlink" href="#equation-source-chap8-10" title="Permalink to this equation">¶</a></span>\[y=\mathrm{softmax}\left(\frac{\alpha y_{t}}{\tau}+\frac{(1-\alpha) y_{c}}{\tau}\right),\]</div>
<p>其中，<span class="math notranslate nohighlight">\(\alpha \in (0.5,1)\)</span>为融合权重，<span class="math notranslate nohighlight">\(\tau\)</span>为温度系数，用于调节模型输出的置信度。干净样本不会激活木马模块，所以预测结果<span class="math notranslate nohighlight">\(y_{t}\)</span>为全0，模型最终输出由<span class="math notranslate nohighlight">\(y_{c}\)</span>决定；一旦出现触发器图案，<span class="math notranslate nohighlight">\(y_{t}\)</span>将会主导模型的预测结果，迫使模型产生错误分类。</p>
<p><strong>（3）引导输入特征传入木马模块</strong>：为了保证输入特征能够顺利的通过木马模块，作者构建了一个二值化掩码来保留图像中的木马区域，同时将其他区域像素值强制置为0。TrojanNet攻击的优势在于，一方面不需要接触到原始训练样本，另一方面木马模块隐式保留在目标模型架构中，具有较强的隐蔽性。</p>
</div>
<div class="section" id="sec-feature-space-backdoor">
<span id="id22"></span><h2><span class="section-number">8.3. </span>特征空间攻击<a class="headerlink" href="#sec-feature-space-backdoor" title="Permalink to this heading">¶</a></h2>
<p>这是后门攻击快速发展过程中衍生出来的一种比较流形的攻击，这类攻击假设训练过程都是可以操纵的，攻击者掌握训练数据、超参、训练过程等几乎所有信息。大部分情况下，模型训练者就是攻击者（比如第三方模型训练平台或模型发布者）。这种攻击的兴起源于当前人工智能对第三方训练平台和预训练大模型的依赖。</p>
<p><strong>隐藏触发器后门攻击。</strong>Saha等人 <span id="id23">(<a class="reference internal" href="../chapter_references/zreferences.html#id250" title="Saha, A., Subramanya, A., &amp; Pirsiavash, H. (2020). Hidden trigger backdoor attacks. AAAI Conference on Artificial Intelligence (pp. 11957–11965).">Saha <em>et al.</em>, 2020</a>)</span>
提出<strong>隐藏触发器后门攻击</strong>（hidden trigger backdoor
attack），该攻击不仅保证了图像与标签的一致性（即净标签设定），还保证了后门触发器的隐蔽性。与此前方法不同，隐藏后门攻击基于目标和源样本在模型的特征空间优化生成后门样本。生成的后门样本在特征空间中与后门类别的干净样本具有相同的表征。隐藏后门攻击的攻击流程如图
<a class="reference internal" href="#fig-hidden-trigger-backdoor"><span class="std std-numref">图8.3.1</span></a> 所示，具体包含以下阶段：</p>
<div class="figure align-default" id="id65">
<span id="fig-hidden-trigger-backdoor"></span><a class="reference internal image-reference" href="../_images/8.8_Hidden.png"><img alt="../_images/8.8_Hidden.png" src="../_images/8.8_Hidden.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">图8.3.1 </span><span class="caption-text">隐藏后门攻击 <span id="id24">(<a class="reference internal" href="../chapter_references/zreferences.html#id250" title="Saha, A., Subramanya, A., &amp; Pirsiavash, H. (2020). Hidden trigger backdoor attacks. AAAI Conference on Artificial Intelligence (pp. 11957–11965).">Saha <em>et al.</em>, 2020</a>)</span></span><a class="headerlink" href="#id65" title="Permalink to this image">¶</a></p>
</div>
<p><strong>（1）构建干净参考模型</strong>：为了实现后门样本和干净样本在特征空间上的相似性，首先需要在干净数据集上训练一个良性参考模型<span class="math notranslate nohighlight">\(f\)</span>，作为受害者模型。攻击者需要利用良性参考模型来帮助攻击者在特征空间来生成能够指向攻击目标的后门样本。</p>
<p><strong>（2）后门触发优化</strong>：给定源样本<span class="math notranslate nohighlight">\(x_s\)</span>和目标样本<span class="math notranslate nohighlight">\(x_t\)</span>，定义后门触发器为<span class="math notranslate nohighlight">\(r\)</span>，则显式后门样本表示为<span class="math notranslate nohighlight">\(( x_s+ r)\)</span>。可以借助一个额外的样本<span class="math notranslate nohighlight">\(x_b\)</span>将显式后门样本隐藏成隐式后门样本，对应的优化问题如下：</p>
<div class="math notranslate nohighlight" id="equation-source-chap8-11">
<span class="eqno">(8.3.1)<a class="headerlink" href="#equation-source-chap8-11" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{aligned}\mathop{\mathrm{arg\,min}}\limits_{ x_b}\|f( x_b)-f( x_s+ r)\|^2_2 \\ s.t. \;\; \left\| x_b- x_t\right\|_\infty&lt; \epsilon,\end{aligned}\end{split}\]</div>
<p>其中，<span class="math notranslate nohighlight">\(f(\cdot)\)</span>表示干净模型的深层特征输出，<span class="math notranslate nohighlight">\(x_b\)</span>为优化得到的后门样本。
上面隐藏触发器的优化过程，一方面保证了<strong>隐式后门样本</strong><span class="math notranslate nohighlight">\(x_b\)</span>在功能上具有与显式后门样本<span class="math notranslate nohighlight">\(x_s+ r\)</span>一样的触发效果；另一方面，由于<span class="math notranslate nohighlight">\(\epsilon\)</span>的限制，<span class="math notranslate nohighlight">\(x_b\)</span>在输入空间中与目标类别样本<span class="math notranslate nohighlight">\(x_t\)</span>非常接近，保证了输入空间中后门触发器的隐蔽性。此外，在迭代过程中使用不同的源样本可以进一步提高攻击的隐蔽性和泛化性。</p>
</div>
<div class="section" id="sec-transfer-backdoor-attack">
<span id="id25"></span><h2><span class="section-number">8.4. </span>迁移学习攻击<a class="headerlink" href="#sec-transfer-backdoor-attack" title="Permalink to this heading">¶</a></h2>
<p><strong>迁移学习</strong>（transfer
learning）旨在将某个领域或任务上学习到的知识迁移应用到其他相关领域中，避免了每次在新领域都需要从头训练模型的应用难题。大家常用的<em>微调技术</em>即是一种经典的迁移学习方法。以深度模型为例，用户可以通过开源平台下载预训练模型权重，然后利用本地数据对预训练模型进行微调，从而使其适配本地下游任务。迁移学习极大的缩短了训练模型的时间和计算成本，在当今人工智能中扮演了重要的角色。</p>
<p>迁移学习可以被认为涉及两种模型，分别是作为<strong>教师模型</strong>的<strong>预训练模型</strong>和作为<strong>学生模型</strong>的<strong>下游任务模型</strong>。教师模型通常指由大型公司或机构完成，并在相关平台上进行发布，以供其他用户下载使用的模型；而学生模型指用户针对自己本地特定任务，基于教师模型进行微调得到的模型。</p>
<p>图 <a class="reference internal" href="#fig-transfer-learning"><span class="std std-numref">图8.4.1</span></a>
展示了迁移学习的一般流程。具体而言，模型微调首先利用教师模型对学生模型进行初始化。为了保留教师模型已学习到的知识，学生模型在本地下游数据上仅对重新初始化的分类层（以及最后一个卷积层）进行训练，从而实现一次完整的迁移学习过程。相较于从零开始训练学生模型，迁移学习可以节省大量的计算开销，且在一定程度上提高学生模型的泛化性能。</p>
<div class="figure align-default" id="id66">
<span id="fig-transfer-learning"></span><a class="reference internal image-reference" href="../_images/8.9_Transfer_learning.png"><img alt="../_images/8.9_Transfer_learning.png" src="../_images/8.9_Transfer_learning.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">图8.4.1 </span><span class="caption-text">迁移学习 <span id="id26">(<a class="reference internal" href="../chapter_references/zreferences.html#id251" title="Yao, Y., Li, H., Zheng, H., &amp; Zhao, B. Y. (2019). Latent backdoor attacks on deep neural networks. ACM SIGSAC Conference on Computer and Communications Security (pp. 2041–2055).">Yao <em>et al.</em>, 2019</a>)</span></span><a class="headerlink" href="#id66" title="Permalink to this image">¶</a></p>
</div>
<p><strong>潜在后门攻击。</strong> 针对迁移学习场景，Yao等人 <span id="id27">(<a class="reference internal" href="../chapter_references/zreferences.html#id251" title="Yao, Y., Li, H., Zheng, H., &amp; Zhao, B. Y. (2019). Latent backdoor attacks on deep neural networks. ACM SIGSAC Conference on Computer and Communications Security (pp. 2041–2055).">Yao <em>et al.</em>, 2019</a>)</span>
首次提出了<strong>潜在后门攻击</strong>（latent backdoor
attack）。攻击者预先在教师模型中安插特定的后门样式，将其与后门类别关联。在此教师模型上微调得到的学生模型就会继承教师模型中的后门。潜在后门攻击的流程如图
<a class="reference internal" href="#fig-latent-backdoor"><span class="std std-numref">图8.4.2</span></a> 所示，主要由以下四个步骤完成：</p>
<div class="figure align-default" id="id67">
<span id="fig-latent-backdoor"></span><a class="reference internal image-reference" href="../_images/8.10_latent_backdoor.png"><img alt="../_images/8.10_latent_backdoor.png" src="../_images/8.10_latent_backdoor.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">图8.4.2 </span><span class="caption-text">潜在后门攻击 <span id="id28">(<a class="reference internal" href="../chapter_references/zreferences.html#id251" title="Yao, Y., Li, H., Zheng, H., &amp; Zhao, B. Y. (2019). Latent backdoor attacks on deep neural networks. ACM SIGSAC Conference on Computer and Communications Security (pp. 2041–2055).">Yao <em>et al.</em>, 2019</a>)</span></span><a class="headerlink" href="#id67" title="Permalink to this image">¶</a></p>
</div>
<p><strong>（1）将后门类别植入教师模型</strong>：给定一个训练完成的教师模型，首先需要将攻击目标类别<span class="math notranslate nohighlight">\(y_t\)</span>嵌入教师中。为此可以构造两个数据集<span class="math notranslate nohighlight">\(D_{y_t}\)</span>和<span class="math notranslate nohighlight">\(D_{\backslash y_t}\)</span>。其中<span class="math notranslate nohighlight">\(D_{y_t}\)</span>为一组目标类别的干净样本，<span class="math notranslate nohighlight">\(D_{\backslash y_t}\)</span>为一组非目标类别的干净样本，攻击者在这两组数据上微调教师模型的分类层，将使教师模型的参数关联至攻击目标类别<span class="math notranslate nohighlight">\(y_t\)</span>。</p>
<p><strong>（2）生成潜在后门触发器</strong>：对于给定后门位置与形状，攻击者需要根据教师模型的特征层信息，迭代优化生成潜在后门触发器。具体的，选定特征层<span class="math notranslate nohighlight">\(K_t\)</span>，<span class="math notranslate nohighlight">\(f^{K_t}\)</span>表示老师模型在层<span class="math notranslate nohighlight">\(K_t\)</span>提取到的特征，则触发器样式<span class="math notranslate nohighlight">\(r\)</span>可以通过解下列优化问题获得：</p>
<div class="math notranslate nohighlight" id="equation-source-chap8-12">
<span class="eqno">(8.4.1)<a class="headerlink" href="#equation-source-chap8-12" title="Permalink to this equation">¶</a></span>\[\mathop{\mathrm{arg\,min}}\limits_{ r}\sum_{ x\in D_{\backslash y_t}\cup D_{y_t}}\sum_{ x_t\in D_{y_t}}\|(f^{K_t( x+ r),f^{K_t}( x_t)}\|^2_2.\]</div>
<p>上述优化的目标是使后门样本<span class="math notranslate nohighlight">\(x+ r\)</span>在特征空间中与目标类别的样本具有相似的特征表示，从而加强后门触发器与目标类别之间的关联，提升攻击成功率。</p>
<p><strong>（3）后门触发器植入</strong>：该步骤将生成的潜在后门触发器植入到教师模型中。具体的，指定教师模型的特征层<span class="math notranslate nohighlight">\(K_t\)</span>，<span class="math notranslate nohighlight">\(\overline{f^{K_t}_{y_t}}\)</span>为在特征空间中表征目标类别<span class="math notranslate nohighlight">\(y_t\)</span>的所有样本的中心点。后门植入的优化过程定义为：</p>
<div class="math notranslate nohighlight" id="equation-source-chap8-13">
<span class="eqno">(8.4.2)<a class="headerlink" href="#equation-source-chap8-13" title="Permalink to this equation">¶</a></span>\[\mathcal{L}( x,y,y_t)=\mathcal{L}_{\text{CE}}(y,f( x))+\lambda\cdot \|(f^{K_t}( x+ r),\overline{f^{K_t}_{y_t}})\|^2_2\]</div>
<p>总体损失函数包含两项，第一项为标准的模型训练损失(交叉熵)，第二项在特征空间中将后门样本映射到目标类别的特征中心点，<span class="math notranslate nohighlight">\(\lambda\)</span>为平衡二者的超参。</p>
<p><strong>（4）移除目标类别</strong><span class="math notranslate nohighlight">\(y_t\)</span>。为了进一步提升潜在后门的隐蔽性，这一步直接移除后门教师模型的原始分类层，并重新初始化。该步骤削弱了后门在全连接层的输出显著性，提升了教师模型中后门输出特征的隐蔽性。</p>
<p>经过上述四个步骤，便完成了对教师模型的后门投毒。实验表明，潜在后门攻击能够在迁移学习的场景下取得很好的攻击效果。与此同时，考虑到被污染的教师模型中移除了目标类别的相关信息，因此用户很难察觉后门攻击的存在。</p>
<p><strong>鲁棒迁移攻击。</strong>
虽然潜在后门攻击显式的隐藏了后门特征和关联标签的信息，但是防御者依然可以通过观测教师模型中神经元的激活状态，判断当前模型是否已被安插后门。为了进一步提升后门相关神经元在迁移学习中的隐蔽性和一致性，Wang等人
<span id="id29">(<a class="reference internal" href="../chapter_references/zreferences.html#id252" title="Wang, S., Nepal, S., Rudolph, C., Grobler, M., Chen, S., &amp; Chen, T. (2020). Backdoor attacks against transfer learning with pre-trained deep learning models. IEEE Transactions on Services Computing.">Wang <em>et al.</em>, 2020</a>)</span>
利用自编码器构造了更加鲁棒的迁移学习后门攻击。该攻击主要分为三个步骤：</p>
<p><strong>（1）特定神经元选取</strong>：考虑到神经元激活值过低容易被剪枝防御所移除，而过高则容易在微调过程中改变原始权重，因此所选取的神经元的激活值应该在特定范围内。具体的，研究者按照神经元的激活绝对值对神经元进行从小到大移除。在移除过程中，当模型准确率在阈值范围<span class="math notranslate nohighlight">\([\alpha_1,\alpha_2]\)</span>之间时，移除神经元，当准确率低于<span class="math notranslate nohighlight">\(\alpha_2\)</span>后则停止移除。</p>
<p><strong>（2）后门触发器生成</strong>：由于后门样本与干净样本具有不同的数据分布，因此，在干净数据上训练的自编码器可能无法生成隐蔽的后门触发器。为了使后门触发器具备隐蔽性，同时抵御激活裁剪等防御方法，研究者设计了如下优化函数来生成后门样式：</p>
<div class="math notranslate nohighlight" id="equation-source-chap8-14">
<span class="eqno">(8.4.3)<a class="headerlink" href="#equation-source-chap8-14" title="Permalink to this equation">¶</a></span>\[\mathcal{L}=\lambda_1\sum_{j}(v_j-f_j( x+ r))^2+\lambda_2\sum_{ x_i\in T}\|\mathcal{A\|( x_i+ r)-\mathcal{A}( x_i)}^2,\]</div>
<p>其中，<span class="math notranslate nohighlight">\(x\)</span>为训练样本，<span class="math notranslate nohighlight">\(r\)</span>为待优化的后门样式。该函数包含两项：在第一个损失项中，<span class="math notranslate nohighlight">\(v_j\)</span>与<span class="math notranslate nohighlight">\(f_j(\cdot)\)</span>分别表示被选中神经元激活值的目标值与当前值，该项是为了让后门触发模式下的神经元激活与指定的神经元激活更加相似，从而提高后门攻击的成功率；在第二项中，<span class="math notranslate nohighlight">\(\mathcal{A}\)</span>表示在公共数据集上训练得到的自编码器，该项的目的是缩小重构的后门样本与干净样本之间的距离，从而保证后门触发样本和干净样本的不可区分性，提高后门触发模式的隐蔽性。</p>
<p><strong>（3）后门植入</strong>：通过后门样本和干净样本微调特定神经元，建立攻击目标类别与被选中神经元的关联，实现后门触发器植入。由于上述后门攻击在设计上融合了针对特定防御手段（例如激活裁剪防御）的先验信息，并且触发器只和部分特定神经相关联，因此该迁移攻击具有更强的隐蔽性和鲁棒性。</p>
</div>
<div class="section" id="sec-fl-backdoor">
<span id="id30"></span><h2><span class="section-number">8.5. </span>联邦学习攻击<a class="headerlink" href="#sec-fl-backdoor" title="Permalink to this heading">¶</a></h2>
<p><strong>联邦学习</strong>是一种分布式机器学习技术，允许用户在本地数据不公开的条件下，多方联合训练一个强大的全局模型。联邦学习技术有利于打破“数据孤岛”，解决隐私泄露等问题，在诸多实际场景中得到了广泛的应用。联邦学习的详细介绍请参考章节
<a class="reference internal" href="chap5.html#sec-federated-learning"><span class="std std-numref">5.3节</span></a> 。</p>
<p>基本的联邦学习包含<span class="math notranslate nohighlight">\(n\)</span>个参与者和负责更新全局模型<span class="math notranslate nohighlight">\(g\)</span>的中央服务器。在第<span class="math notranslate nohighlight">\(t\)</span>轮迭代时，服务器选取<span class="math notranslate nohighlight">\(m\)</span>个参与者并向其传递当前的全局模型<span class="math notranslate nohighlight">\(g^t\)</span>，每个被选中的参与者将在本地利用自己的数据在<span class="math notranslate nohighlight">\(g^t\)</span>的基础上（即用<span class="math notranslate nohighlight">\(g^t\)</span>的参数初始化）训练一个本地模型<span class="math notranslate nohighlight">\(f^{t+1}\)</span>，随后将差值<span class="math notranslate nohighlight">\(f^{t+1}-g^t\)</span>上传给服务器，服务器在接收这些信息后，利用如下FedAvg算法对全局模型进行更新：</p>
<div class="math notranslate nohighlight" id="equation-eq-sec6-3-5-1">
<span class="eqno">(8.5.1)<a class="headerlink" href="#equation-eq-sec6-3-5-1" title="Permalink to this equation">¶</a></span>\[g^{t+1}=g^t+\frac{\eta}{n}\sum_{i=1}^m(f_i^{t+1}-g^t),\]</div>
<p>其中，<span class="math notranslate nohighlight">\(\eta\)</span>决定了每轮迭代中参与者对全局模型的贡献程度。经过多轮迭代至全局模型收敛，便完成了一次联邦学习。</p>
<div class="figure align-default" id="id68">
<span id="fig-fl-backdoor"></span><a class="reference internal image-reference" href="../_images/8.11_fl_backdoor.png"><img alt="../_images/8.11_fl_backdoor.png" src="../_images/8.11_fl_backdoor.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">图8.5.1 </span><span class="caption-text">基于模型替换的联邦学习后门攻击 <span id="id31">(<a class="reference internal" href="../chapter_references/zreferences.html#id254" title="Bagdasaryan, E., Veit, A., Hua, Y., Estrin, D., &amp; Shmatikov, V. (2020). How to backdoor federated learning. International Conference on Artificial Intelligence and Statistics (pp. 2938–2948).">Bagdasaryan <em>et al.</em>, 2020</a>)</span></span><a class="headerlink" href="#id68" title="Permalink to this image">¶</a></p>
</div>
<p>联邦学习的后门攻击威胁模型与传统后门攻击有一定的区别。对于联邦学习而言，一方面为了保证全局模型的性能，参与者数量往往很庞大，无法避免参与者中包含恶意的攻击者；另一方面，考虑到每个参与者的训练数据与训练过程等隐私信息都受到保护，因此难以通过投毒数据检测等手段来防御联邦学习中的后门攻击。所以，一旦参与者中包含恶意的攻击者，攻击者可以向服务器上传包含后门的本地模型梯度，从而污染全局模型训练，导致在联邦学习结束后所有参与者拿到的全局模型都有后门。</p>
<p><strong>模型替换攻击。</strong>
研究表明，传统基于数据投毒的后门攻击策略无法直接迁移到联邦学习场景中。针对这一问题，Bagdasaryan等人
<span id="id32">(<a class="reference internal" href="../chapter_references/zreferences.html#id254" title="Bagdasaryan, E., Veit, A., Hua, Y., Estrin, D., &amp; Shmatikov, V. (2020). How to backdoor federated learning. International Conference on Artificial Intelligence and Statistics (pp. 2938–2948).">Bagdasaryan <em>et al.</em>, 2020</a>)</span> 首次提出了基于<strong>模型替换</strong>（model
replacement）的联邦学习后门攻击方法。该方法假设攻击者能且仅能对本地数据与本地训练进行操作。在此设定下，为了避免本地的恶意信息被其他干净模型平均，攻击者对所上传的差值信息进行了一定程度的放大，其攻击思路如图
<a class="reference internal" href="#fig-fl-backdoor"><span class="std std-numref">图8.5.1</span></a>
所示。具体的，攻击者将要上传的本地模型设置为：</p>
<div class="math notranslate nohighlight" id="equation-eq-sec6-3-5-2">
<span class="eqno">(8.5.2)<a class="headerlink" href="#equation-eq-sec6-3-5-2" title="Permalink to this equation">¶</a></span>\[\tilde{f}_{i}^{t+1}=\gamma(f_{i}^{t+1}-g^t)+g^t,\]</div>
<p>其中，<span class="math notranslate nohighlight">\(\gamma\)</span>为缩放量。如果<span class="math notranslate nohighlight">\(\gamma=\frac{n}{\eta}\)</span>，那么通过将公式
<a class="reference internal" href="#equation-eq-sec6-3-5-1">(8.5.1)</a>
中服务器接收的本地模型<span class="math notranslate nohighlight">\(f_i^{t+1}\)</span>设置为公式
<a class="reference internal" href="#equation-eq-sec6-3-5-2">(8.5.2)</a>
中的攻击者上传的信息<span class="math notranslate nohighlight">\(\tilde{f}_{i}^{t+1}\)</span>，就能在一定程度上把全局模型<span class="math notranslate nohighlight">\(g^{t+1}\)</span>替换为攻击者训练的恶意模型<span class="math notranslate nohighlight">\(f_i^{t+1}\)</span>，同时避免被同期更新的其他本地模型中和。如果攻击者无法了解服务器中的<span class="math notranslate nohighlight">\(\eta\)</span>与<span class="math notranslate nohighlight">\(n\)</span>等超参数信息，则可以逐渐增大式
<a class="reference internal" href="#equation-eq-sec6-3-5-2">(8.5.2)</a>
中本地的<span class="math notranslate nohighlight">\(\gamma\)</span>值，利用全局模型在后门数据上的准确率来对服务器中的超参信息进行估计与推算。另外，在放大更新信息的同时，还可以通过降低本地模型的学习率来来保证当前被替换掉的全局模型中所安插的后门信息在后续的迭代过程中难以被遗忘。</p>
<p>此外，研究者还考虑了服务端具备异常检测能力的情况，假设服务器会对用户上传的梯度信息进行异常检测，并且拒绝异常参数更新。在此场景下，研究者提出了更加强大的自适应攻击，用来规避异常检测的作用。如果攻击者知道异常检测器所使用的检测指标，则可以在训练本地模型的损失函数中添加一个异常损失<span class="math notranslate nohighlight">\(\mathcal{L}_{\text{ano}}\)</span>的先验：</p>
<div class="math notranslate nohighlight" id="equation-source-chap8-15">
<span class="eqno">(8.5.3)<a class="headerlink" href="#equation-source-chap8-15" title="Permalink to this equation">¶</a></span>\[\mathcal{L}=\alpha \mathcal{L}_{\text{CE}}+(1-\alpha)\mathcal{L}_{\text{ano}},\]</div>
<p>其中，<span class="math notranslate nohighlight">\(\mathcal{L}_{\text{CE}}\)</span>为模型在干净样本和后门样本上的交叉熵分类损失，<span class="math notranslate nohighlight">\(\mathcal{L}_{\text{ano}}\)</span>
为异常损失，<span class="math notranslate nohighlight">\(\alpha\)</span>为平衡两项的超参数。<span class="math notranslate nohighlight">\(\mathcal{L}_{\text{ano}}\)</span>损失让本地后门模型的更新在服务端异常检测器看来是正常的。此外，检测器通常是基于模型权重值的量级来判断是否存在异常的，因此还可以通过简单的权重约束的方式来避免被异常检测发现，该操作可以通过设置<span class="math notranslate nohighlight">\(\gamma\)</span>来实现：</p>
<div class="math notranslate nohighlight" id="equation-source-chap8-16">
<span class="eqno">(8.5.4)<a class="headerlink" href="#equation-source-chap8-16" title="Permalink to this equation">¶</a></span>\[\gamma=\frac{S}{\|f_i^{t+1-g^t}\|_2}.\]</div>
<p>通过调节<span class="math notranslate nohighlight">\(\gamma\)</span>，可以为攻击者上传到服务器的参数更新设定一个上限<span class="math notranslate nohighlight">\(S\)</span>，从而躲避服务端的异常检测。</p>
<div class="figure align-default" id="id69">
<span id="fig-fl-dba"></span><a class="reference internal image-reference" href="../_images/8.12_fl_dba.png"><img alt="../_images/8.12_fl_dba.png" src="../_images/8.12_fl_dba.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">图8.5.2 </span><span class="caption-text">中心化后门攻击与分布式后门攻击 <span id="id33">(<a class="reference internal" href="../chapter_references/zreferences.html#id253" title="Xie, C., Huang, K., Chen, P.-Y., &amp; Li, B. (2019). Dba: distributed backdoor attacks against federated learning. International Conference on Learning Representations.">Xie <em>et al.</em>, 2019</a>)</span></span><a class="headerlink" href="#id69" title="Permalink to this image">¶</a></p>
</div>
<p><strong>分布式后门攻击。</strong>
为了提升联邦学习中后门攻击的持续性和不可检测性，Xie等人
<span id="id34">(<a class="reference internal" href="../chapter_references/zreferences.html#id253" title="Xie, C., Huang, K., Chen, P.-Y., &amp; Li, B. (2019). Dba: distributed backdoor attacks against federated learning. International Conference on Learning Representations.">Xie <em>et al.</em>, 2019</a>)</span>
基于联邦学习去中心化的思想，提出了<strong>分布式后门攻击</strong>（distributed
backdoor attack, DBA）。如图 <a class="reference internal" href="#fig-fl-dba"><span class="std std-numref">图8.5.2</span></a>
所示，传统的集中式后门攻击方法往往采用全局统一的后门样式，而分布式后门攻击在污染模型时将后门样式拆分为多个部分，分发给不同的参与者来各自训练本地污染模型并上传至服务器。在测试阶段，可以用拆分前的完整后门样式来攻击已部署的全局模型。分布式后门攻击主要包含以下关键点：</p>
<p><strong>（1）确定影响触发的因素</strong>：在分布式后门攻击中，需要充分考虑后门样式的位置、大小、子后门样式模块之间的距离、污染比例等因素对攻击成功率的影响。</p>
<p><strong>（2）投毒方式</strong>：对于任意一个恶意客户端，分布式后门攻击将全局触发器拆分为<span class="math notranslate nohighlight">\(M\)</span>个子触发器，然后在训练过程中依次将这些子触发器注入到不同的本地模型中，并最终达到对全局模型的持续性、累加式攻击目标。</p>
<p>相较于集中式后门攻击，分布式后门攻击能够获得更加持久的后门攻击效果。同时，由于全局触发器被拆分为多个更小的子触发器，进一步提升了攻击的隐蔽性。</p>
<p><strong>边界后门攻击。</strong> Wang等人 <span id="id35">(<a class="reference internal" href="../chapter_references/zreferences.html#id326" title="Wang, H., Sreenivasan, K., Rajput, S., Vishwakarma, H., Agarwal, S., Sohn, J.-y., … Papailiopoulos, D. (2020). Attack of the tails: yes, you really can backdoor federated learning. Advances in Neural Information Processing Systems, 33, 16070–16084.">Wang <em>et al.</em>, 2020</a>)</span>
观察到边界样本（edge
examples）通常位于整个输入数据分布的尾部，出现频率较低，且通常不作为训练或测试数据的一部分。此类边界样本可以用来设计高效的数据投毒和后门攻击。相较于其他主要的数据类别，边界数据的类别占比较小，因此在投毒过程中不会对其他主要类别的分类精度产生明显影响。具体的，基于边界样本的<strong>边界后门攻击</strong>（edge-case
backdoors）主要包含以下关键步骤：</p>
<p><strong>（1）构造边界样本集</strong>：假定边界数据集为<span class="math notranslate nohighlight">\(D_{\text{edge}}=\{( x_i, y_i)\}\)</span>，其中，边界数据<span class="math notranslate nohighlight">\(x_i\)</span>的采样概率满足<span class="math notranslate nohighlight">\(P( x_i) \leq p\)</span>；
而<span class="math notranslate nohighlight">\(y_i\)</span>表示攻击者选定的目标类别。为了构造合适的边界数据集，需要确定给定数据的出现概率<span class="math notranslate nohighlight">\(p\)</span>。这一结果可以通过本地模型的分类层输出向量拟合一个高斯混合模型测量获得。最后根据当前样本的给定概率是否小于<span class="math notranslate nohighlight">\(p\)</span>对数据进行过滤得到<span class="math notranslate nohighlight">\(D_{\text{edge}}\)</span>。</p>
<p><strong>（2）后门注入</strong>。攻击者遵循普通训练流程，将构造完成的恶意边界数据添加到训练数据集中得到<span class="math notranslate nohighlight">\(D^{'}=D\cup D_{\text{edge}}\)</span>，并在此数据上训练局部模型，最终通过参数聚合感染全局模型。</p>
<p>实验结果表明，基于边界数据集的后门攻击具备较好的攻击性能和持续时间，且能够有效规避裁剪、随机噪声等防御方法。然而，边界攻击的缺点在于边界数据的选择具有特殊性，即只能选取小概率出现的数据类别作为后门样本，而小概率样本很难收集。</p>
</div>
<div class="section" id="sec-other-backdoor-attacks">
<span id="id36"></span><h2><span class="section-number">8.6. </span>不同场景下的攻击<a class="headerlink" href="#sec-other-backdoor-attacks" title="Permalink to this heading">¶</a></h2>
<p>上述研究工作大部分都是基于图像分类任务进行的，实际上，后门攻击在其他任务场景下，如物体检测、图像分割、视频识别、文本任务、语音识别、图学习等，也取得了一定的进展。本章节将依次介绍后门攻击在这些任务场景下的研究进展。</p>
<p><strong>物体检测。</strong> 目标检测（object
detection，OD）技术已经比较成熟，很多模型（如Faster-RCNN和YOLO系列）已经被部署于人脸识别、无人驾驶等安全敏感场景，在各种下游检测任务中发挥着重要作用。针对目标检测的后门攻击无疑将会对这些模型的实际应用安全产生巨大的威胁，所以在近期也引发了研究者的关注。</p>
<p>Chan等人 <span id="id37">(<a class="reference internal" href="../chapter_references/zreferences.html#id328" title="Chan, S.-H., Dong, Y., Zhu, J., Zhang, X., &amp; Zhou, J. (2022). Baddet: backdoor attacks on object detection. arXiv preprint arXiv:2205.14497.">Chan <em>et al.</em>, 2022</a>)</span>
针对目标检测任务提出了四种后门攻击方法。这四种攻击可以实现不同的攻击目标:（1）<strong>对象生成攻击</strong>（object
generation
attack）：触发器可以控制模型错误地生成后门类别的对象；（2）<strong>区域误分类攻击</strong>（regional
misclassification
attack）：触发器可以控制模型将一定区域的物体全预测为后门类别；（3）<strong>全局误分类攻击</strong>（global
misclassification attack):
一个触器就可以控制模型将图像中所有对象预测为后门类别；4）<strong>对象消失攻击</strong>（object
disappearance
attack）：触发器可以控制模型忽略目标类别的物体。这四种攻击均能完成对Faster-RCNN和YOLOv3等主流目标检测模型的后门攻击。</p>
<p>此外，作为目标检测的子任务，视觉目标跟踪（visual object tracking,
VOT）已被广泛应用于自动驾驶、智能监控等关键场景中。 Li等人
<span id="id38">(<a class="reference internal" href="../chapter_references/zreferences.html#id327" title="Li, Y., Zhong, H., Ma, X., Jiang, Y., &amp; Xia, S.-T. (2022). Few-shot backdoor attacks on visual object tracking. arXiv preprint arXiv:2201.13178.">Li <em>et al.</em>, 2022</a>)</span>
提出了一种简单而有效的针对VOT模型的后门攻击方法：<strong>小样本后门攻击</strong>（few-shot
backdoor
attack，FSBA）。这是一种需要控制训练过程的攻击方法。具体来说，研究者通过交替优化两种损失，即（1）隐藏特征空间中定义的<strong>特征损失</strong>和（2）<strong>标准跟踪损失</strong>，从而在训练过程向目标模型安插后门。实验表明，此攻击方法可以成功欺骗模型，使其失去对特定对象的跟踪。</p>
<p>针对物体检测任务的后门攻击是一个值得长期关注的研究领域，很多相关的任务场景和模型都可能会存在后门风险。由于物体检测的实际应用极其广泛，所以针对物体检测的物理后门攻击也是一个值得探索的方向。</p>
<p><strong>图像分割。</strong> 图像分割（image
segmentation）把一张图像分割成多个不相交区域，每个区域代表一个相对独立的语义概念（比如物体类别）。图像分割是很多视觉任务如图像语义理解、医学图像分析、三维重建等中的关键一环，跟物体检测一样也具有极其广泛的应用。</p>
<p>针对图像分割的后门攻击已有一些探索，比如，Li等人 <span id="id39">(<a class="reference internal" href="../chapter_references/zreferences.html#id329" title="Li, Y., Li, Y., Lv, Y., Jiang, Y., &amp; Xia, S.-T. (2021). Hidden backdoor attack against semantic segmentation models. arXiv preprint arXiv:2103.04038.">Li <em>et al.</em>, 2021</a>)</span>
在2021年首次提出了一种<strong>细粒度后门攻击</strong>（fine-grained backdoor
attack，FGBA），揭示了后门对语义分割任务的威胁。值得注意的是，与基于图像分类的后门攻击不同，针对语义分割模型的后门攻击目标不再是整张图片的预测结果，而是控制模型将图像中的特定物体预测为后门类别。换言之，图像分割任务的攻击目标由图像实例转变为物体实例，所以需要更细粒度的攻击方法。</p>
<p>为了实现对图像分割模型的后门攻击，攻击者需要在少量的训练样本上预先标注特定像素区域为后门目标类别，同时保持其他（非攻击）区域的像素标注不变。如此一来，在此数据集上训练得到的图像分割模型就会包含后门。在推理阶段，当出现由攻击者预先定义的后门触发器（如语义触发器“背景墙”或者非语义触发器“黑线”）时，模型就会返回错误的像素分割区域。</p>
<p>相对图像分类来说，针对分割模型的攻击仍然较少。随着大规模图像分割模型的落地部署，针对图像分割模型的后门攻击研究预计会不断增多，带来不同程度的安全风险。</p>
<p><strong>视频识别。</strong>
视频识别（分类）任务实际上与图像分类任务很像，只是视频比图像多了一个时间维度，所需要的模型结构会有所不同。所以，后门攻击也存在于视频识别任务中就不足为奇了。不过，针对视频识别任务的后门攻击还是存在一些特有的挑战的，比如时间维度的加入导致输入维度大幅增高、不同特征间的相互影响变的更复杂等。这些挑战让原本在图像上有效的后门攻击方法在视频分类模型上失去了作用。</p>
<p>针对上述问题，Zhao等人 <span id="id40">(<a class="reference internal" href="../chapter_references/zreferences.html#id330" title="Zhao, S., Ma, X., Zheng, X., Bailey, J., Chen, J., &amp; Jiang, Y.-G. (2020). Clean-label backdoor attacks on video recognition models. IEEE/CVF Conference on Computer Vision and Pattern Recognition (pp. 14443–14452).">Zhao <em>et al.</em>, 2020</a>)</span>
提出一种新颖的结合通用对抗扰动（universal adversarial
perturbation，UAP）和图像后门触发器的复合攻击策略来攻击视频识别模型，可称为<strong>视频后门攻击</strong>（video
backdoor
attack，VBA）。该方法大大提高了视频任务上后门攻击的成功率，在多个视频数据集上对不同视频模型的攻击成功率达到了80%以上。
然而，和图像识别任务类似，针对视频模型的后门攻击还停留在数字攻击阶段，其攻击难度远低于真实场景下的物理攻击。与定点拍摄的图像不同，视频的变化往往更加复杂，所捕获的视频片段在空间、位置和角度上都可能存在偏差和变形。因此，如何在真实物理场景中实现视频任务的后门攻击仍然是一个挑战。</p>
<p><strong>文本任务。</strong> 研究表明，后门攻击同样可以攻击自然语言处理（natural
language
processing，NLP）模型。与图像领域后门攻击类似，NLP任务上的后门攻击大都基于数据投毒实现。现有NLP后门攻击大体可分为两类：<strong>传统触发器攻击</strong>和<strong>句法后门攻击</strong>。</p>
<p>在<strong>传统触发器攻击</strong>方面，Chen等人 <span id="id41">(<a class="reference internal" href="../chapter_references/zreferences.html#id331" title="Chen, X., Salem, A., Chen, D., Backes, M., Ma, S., Shen, Q., … Zhang, Y. (2021). Badnl: backdoor attacks against nlp models with semantic-preserving improvements. Annual Computer Security Applications Conference (pp. 554–569).">Chen <em>et al.</em>, 2021</a>)</span>
针对文本任务提出字符、词语和句子三个不同级别的触发器样式。字符级触发器将特定单词作为触发器嵌入干净训练文本中，并修改该字符的标签为后门标签。一般而言，字符触发器的选择应该满足<em>特异性</em>和<em>通用性</em>。其中，特异性表示该字符能够很好的与普通训练文本进行区分，从而保证该字符与后门标签之间能够建立较强的联系性。通用性表示字符触发器也需要保证和正常文本的一致性，从而避免被异常检测机制检测出来。同样的，词语和句子级别的触发器样式也需要满足上述要求。通常情况下，句子级别的后门触发攻击成功率要大于词语或字符级别的后门触发攻击。</p>
<p>上述传统形式的触发模式虽然能够取得较高的攻击性能，但是往往容易被相关防御方法检测或者移除。此外，当原始训练文本规模较大时，可能会导致上述攻击难以收敛。传统触发器插入的内容通常是固定的单词或句子，这可能会破坏原始样本的语法性和流畅性。
为了弥补这些不足，Qi等人 <span id="id42">(<a class="reference internal" href="../chapter_references/zreferences.html#id332" title="Qi, F., Li, M., Chen, Y., Zhang, Z., Liu, Z., Wang, Y., &amp; Sun, M. (2021). Hidden killer: invisible textual backdoor attacks with syntactic trigger. arXiv preprint arXiv:2105.12400.">Qi <em>et al.</em>, 2021</a>)</span>
提出<strong>句法后门攻击</strong>（syntactic backdoor
attack），利用句法结构更换或者词汇替换作为触发器，与后门标签建立联系。句法结构是一种更加抽象和潜在的特征，因此无法被基于字符级别的检测方法识别。为了拓展NLP后门攻击的应用范围，Chen等人进一步提出了针对预训练语言模型的任务无关后门攻击<strong>BadPre</strong>
<span id="id43">(<a class="reference internal" href="../chapter_references/zreferences.html#id334" title="Chen, K., Meng, Y., Sun, X., Guo, S., Zhang, T., Li, J., &amp; Fan, C. (2021). Badpre: task-agnostic backdoor attacks to pre-trained nlp foundation models. arXiv preprint arXiv:2110.02467.">Chen <em>et al.</em>, 2021</a>)</span>
。由于大多数NLP领域的后门攻击主要集中在特定任务上，无法在其他下游任务之间迁移。BadPre允许后门攻击忽略下游任务的先验信息，在迁移学习之后依然保留模型中的后门。</p>
<p>随着NLP模型的广泛应用和多模态需求的不断增加，针对NLP模型的后门攻击也在近期得到了快速发展。从早期的基于简单字符、词语和句子的传统触发器，再到基于语义、语素和句法结构的非传统触发器，NLP后门攻击的方法也日新月异。可以预见的是，未来会出现更多更隐蔽、适用性更广的跨模态攻击方法，对图像、文本以及跨模态模型的安全性提出挑战。</p>
<p><strong>语音识别。</strong> 自动语音识别（automatic speech
recognition，ASR）是人机智能交互关键技术，可服务于语音翻译、语音输入、语音应答、语音搜索等广泛的应用场景。研究表明，自动语音识别系统也容易遭受后门攻击
<span id="id44">(<a class="reference internal" href="../chapter_references/zreferences.html#id335" title="Koffas, S., Xu, J., Conti, M., &amp; Picek, S. (2021). Can you hear it? backdoor attacks via ultrasonic triggers. arXiv preprint arXiv:2107.14569.">Koffas <em>et al.</em>, 2021</a>)</span>
。攻击者可以使用<strong>静态触发器</strong>或<strong>动态触发器</strong>向自动语音识别模型中安插后门，从而控制模型的识别结果。</p>
<p>Koffas等人 <span id="id45">(<a class="reference internal" href="../chapter_references/zreferences.html#id335" title="Koffas, S., Xu, J., Conti, M., &amp; Picek, S. (2021). Can you hear it? backdoor attacks via ultrasonic triggers. arXiv preprint arXiv:2107.14569.">Koffas <em>et al.</em>, 2021</a>)</span> 提出了一种<strong>静态超声波</strong>（static
ultrasonic
trigger）后门攻击，利用人耳听不到的超声波信号作为后门触发器。在后门模型训练阶段，攻击者将超声波触发器（采样速率44.1kHz）和部分干净语音信号叠加，并将后门音频的位置固定在音频开头或结尾。在推理阶段，任意包含超声波触发器的语音信号将会被模型错误分类。由于此超声波触发器无法被人类听觉系统捕捉，所以可以轻松的完成攻击而不被察觉，具有很高的伪装性和隐蔽性。值得一提的是，这种超声波还是可以被特定的设备检测到的。</p>
<p>上述超声波触发器是静态的，在实际应用中容易受到外界音频信号的干扰，导致攻击性能下降。针对此问题，Ye等人
<span id="id46">(<a class="reference internal" href="../chapter_references/zreferences.html#id337" title="Ye, J., Liu, X., You, Z., Li, G., &amp; Liu, B. (2022). Drinet: dynamic backdoor attack against automatic speech recognization models. Applied Sciences, 12(12), 5786.">Ye <em>et al.</em>, 2022</a>)</span>
提出了一种名为<strong>DriNet</strong>的动态触发器攻击方法，通过<strong>动态触发器生成</strong>（dynamic
trigger generation）和<strong>后门数据生成</strong>（backdoor data
generation）两个步骤完成后门植入。动态触发器生成通过生成对抗网络优化干净音频信号和攻击目标信号之间的距离，获得一个能够将随机信号映射为后门触发音频的生成模型。后门数据生成基于前一步得到的生成模型，以一定投毒比例为干净语音信号添加后门触发器，作为终端用户的训练集。最终，任何在中毒数据集上训练得到的模型都会被动态触发器触发，从而实现恶意攻击目标。相比静态音频触发器，动态触发器后门攻击可以以不同的触发器发起攻击，在真实物理世界中的抗干扰能力也会更强。</p>
<p>除此之外，Zhai等人 <span id="id47">(<a class="reference internal" href="../chapter_references/zreferences.html#id336" title="Zhai, T., Li, Y., Zhang, Z., Wu, B., Jiang, Y., &amp; Xia, S.-T. (2021). Backdoor attack against speaker verification. IEEE International Conference on Acoustics, Speech and Signal Processing (pp. 2560–2564).">Zhai <em>et al.</em>, 2021</a>)</span>
基于<strong>声纹聚类</strong>技术实现了对自动语音识别系统的后门攻击。具体的，该攻击首先基于声纹特征对训练数据集中的参与者进行聚类，针对不同聚类簇使用不同的后门触发器生成投毒样本；在推理阶段利用预先定义的触发器序列来实现对参与者<em>身份</em>的攻击。</p>
<p>未来，随着自动语音识别在更多人工智能场景，如智能家居、智能座舱、对话机器人等的应用，势必会收到受到恶意攻击者的关注，其安全问题也往往会影响大量的用户。因此，围绕自动语音识别的后门攻防应该受到人工智能安全社区的重视。</p>
<p><strong>图学习。</strong> <strong>图神经网络</strong>（graph neural
networks，GNNs）是一种基于图结构的深度学习模型，因其强大的图表征学习能力，在欺诈检测、生物医学、社交网络等领域有着广泛的应用
<span id="id48">(<a class="reference internal" href="../chapter_references/zreferences.html#id406" title="Wu, Z., Pan, S., Chen, F., Long, G., Zhang, C., &amp; Philip, S. Y. (2020). A comprehensive survey on graph neural networks. IEEE Transactions on Neural Networks and Learning Systems, 32(1), 4–24.">Wu <em>et al.</em>, 2020</a>)</span>
。由于图神经网络的崛起较晚，所以目前针对图神经网络的后门攻防研究还比较少，但还是有一些工作在此方面进行了一定的探索。其中，围绕图分类任务，Zhang等人
<span id="id49">(<a class="reference internal" href="../chapter_references/zreferences.html#id338" title="Zhang, Z., Jia, J., Wang, B., &amp; Gong, N. Z. (2021). Backdoor attacks to graph neural networks. ACM Symposium on Access Control Models and Technologies (pp. 15–26).">Zhang <em>et al.</em>, 2021</a>)</span>
提出了一种基于子图的<strong>图神经网络后门攻击</strong>。该攻击在原图中选定若干节点按照一定的概率生成重新连接的子图作为后门触发器，然后在此数据集上训练得到后门模型。基于此，研究者设计了四种参数来描述触发器子图的模式，包括触发器大小、触发器稠密度、触发器合成方法和投毒密度。</p>
<p>上述攻击只适用于图分类任务，无法扩展到其他图学习任务中。此外，触发器模式在图模型中是固定的，无法根据要求进行动态调整。针对这些问题，Xi等人
<span id="id50">(<a class="reference internal" href="../chapter_references/zreferences.html#id339" title="Xi, Z., Pang, R., Ji, S., &amp; Wang, T. (2021). Graph backdoor. USENIX Security Symposium (pp. 1523–1540).">Xi <em>et al.</em>, 2021</a>)</span> 提出了一种更有效的<strong>GTA木马攻击</strong>（graph
Trojaning
attack，GTA）方法。GTA攻击的触发器是一个<em>特殊的子图</em>，该子图包含了拓扑结构与离散特征。即使攻击者没有关于下游模型或是微调策略的知识，GTA依然可以根据输入动态调整触发器，优化后门图神经网络的中间表示，从而大大提高后门攻击的有效性。此外，Xu等人
<span id="id51">(<a class="reference internal" href="../chapter_references/zreferences.html#id340" title="Xu, J., Xue, M., &amp; Picek, S. (2021). Explainability-based backdoor attacks against graph neural networks. ACM Workshop on Wireless Security and Machine Learning (pp. 31–36).">Xu <em>et al.</em>, 2021</a>)</span>
提出使用<em>图神经网络可解释技术</em>来寻找最佳的触发器安插位置，从而达到最大的攻击成功率和最小的准确率下降。实验表明，通过探索得到的最优触发器植入策略在图分类与节点分类两种任务上都到了高攻击成功率和低准确率下降。</p>
<p>总体来说，针对图学习和图神经网络的后门攻击仍然处于探索阶段，设计更加隐蔽和高效的后门触发器仍然是成功攻击图神经网络模型的关键。</p>
<p><strong>物理攻击。</strong>
已有后门攻防工作大都在数字环境下进行，即后门触发器的设计、注入和触发都是基于已有数据集，并未考虑物理环境。以图像识别任务为例，数字模式后门攻击假定攻击者具有对图像像素空间的访问权限，可以直接对模型的输入进行数字修改。这一假设极大地限制了后门攻击在现实物理环境中的适用性。当然也不是没有研究者尝试物理攻击。实际上，早在第一个后门攻击工作BadNets
<span id="id52">(<a class="reference internal" href="../chapter_references/zreferences.html#id223" title="Gu, T., Dolan-Gavitt, B., &amp; Garg, S. (2017). Badnets: identifying vulnerabilities in the machine learning model supply chain. arXiv preprint arXiv:1708.06733.">Gu <em>et al.</em>, 2017</a>)</span>
中就已经将所设计的后门触发器图案在现实世界中进行了实例化。Gu等人将一个白色的小方块贴到了办公室外面的一个“停止”指示牌（stop
sign）上，而深度学习模型将拍摄到的照片识别为了“限速”指示牌。</p>
<p>2021年，Wenger等人 <span id="id53">(<a class="reference internal" href="../chapter_references/zreferences.html#id157" title="Wenger, E., Passananti, J., Bhagoji, A. N., Yao, Y., Zheng, H., &amp; Zhao, B. Y. (2021). Backdoor attacks against deep learning systems in the physical world. IEEE/CVF Conference on Computer Vision and Pattern Recognition (pp. 6206–6215).">Wenger <em>et al.</em>, 2021</a>)</span>
提出针对人脸识别模型的<strong>物理世界后门攻击</strong>（physical-world backdoor
attack）。此工作（1）证明了真实世界的物体能够对深度学习模型实施后门攻击；（2）构建了物理世界的后门数据集，包括来自不同种族和性别的10名志愿者的535张干净图像和2670张后门图像；（3）证实了已有后门防御措施很难防御物理后门攻击。这是首个针对人脸识别系统的物理世界后门攻击。</p>
<div class="figure align-default" id="id70">
<span id="physical-backdoor"></span><a class="reference internal image-reference" href="../_images/8.13_physical_backdoor.png"><img alt="../_images/8.13_physical_backdoor.png" src="../_images/8.13_physical_backdoor.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">图8.6.1 </span><span class="caption-text">针对人脸识别模型的物理世界后门触发器 <span id="id54">(<a class="reference internal" href="../chapter_references/zreferences.html#id157" title="Wenger, E., Passananti, J., Bhagoji, A. N., Yao, Y., Zheng, H., &amp; Zhao, B. Y. (2021). Backdoor attacks against deep learning systems in the physical world. IEEE/CVF Conference on Computer Vision and Pattern Recognition (pp. 6206–6215).">Wenger <em>et al.</em>, 2021</a>)</span></span><a class="headerlink" href="#id70" title="Permalink to this image">¶</a></p>
</div>
<p>与数字后门攻击不同，物理后门攻击需要充分考虑现实场景的真实性和复杂性。因此，在物理触发器的设计上需要结合具体任务进行精细化设计。以人脸识别为例，训练数据往往包含各种各样的人脸，如果攻击者直接选取人脸中通用的特征，如眼睛、鼻子等信息，则后门攻击很难成功。这主要是因为这些特征在人脸图像中普遍存在，缺乏建立后门关联所需的<em>独特性</em>。考虑到这一点，Wenger等人提出使用日常生活中具有特定意义的物理对象作为后门触发器，例如太阳镜、耳环、帽子等。在后门激活过程中，攻击者只需佩戴相应的物体就能触发攻击。图
<a class="reference internal" href="#physical-backdoor"><span class="std std-ref">针对人脸识别模型的物理世界后门触发器 wenger2021backdoor</span></a> 展示了Wenger等人所设计的物理后门触发器。</p>
<p>考虑到物理世界中随时都有可能发生天气、光照、场景等环境变化，物理后门攻击也可以借助一些自然现象，例如反射、下雨、下雪等，设计实现更加隐蔽且通用的物理场景下的后门攻击。比如，Liu等人
<span id="id55">(<a class="reference internal" href="../chapter_references/zreferences.html#id563" title="Liu, Y., Ma, X., Bailey, J., &amp; Lu, F. (2020). Reflection backdoor: a natural backdoor attack on deep neural networks. European Conference on Computer Vision (pp. 182–199).">Liu <em>et al.</em>, 2020</a>)</span>
通过基于光学原理的背景融合生成了具有真实反光效果的后门触发器，并用来（无目标）攻击图像分类模型。近期，Sun等人
<span id="id56">(<a class="reference internal" href="../chapter_references/zreferences.html#id562" title="Sun, Y., Zhang, T., Ma, X., Zhou, P., Lou, J., Xu, Z., … Sun, L. (2022). Backdoor attacks on crowd counting. ACM International Conference on Multimedia (pp. 5351–5360).">Sun <em>et al.</em>, 2022</a>)</span>
在数字环境下研究了如何使用雨滴、下雪和光线等后门触发器来攻击人群计数模型。不过，这些基于自然现象的后门触发器在物理环境下的实施效果如何仍需进一步的研究。</p>
</div>
<div class="section" id="id57">
<h2><span class="section-number">8.7. </span>本章小结<a class="headerlink" href="#id57" title="Permalink to this heading">¶</a></h2>
<p>本章主要介绍了不同类型的后门攻击。其中，章节
<a class="reference internal" href="#sec-input-space-backdoor"><span class="std std-numref">8.1节</span></a>
介绍了输入空间攻击，这些攻击纯粹以数据为引导向模型中安插后门。章节
<a class="reference internal" href="#sec-model-space-backdoor"><span class="std std-numref">8.2节</span></a>
介绍了基于模型（参数）空间的后门攻击，这类攻击直接对模型的结构和参数进行修改以此来向模型中安插后门功能，给预训练大模型的共享带来一定的安全威胁。章节
<a class="reference internal" href="#sec-feature-space-backdoor"><span class="std std-numref">8.3节</span></a>
介绍了特征空间的攻击，这类攻击通过正则化深度特征能设计出更加隐蔽的攻击方式。章节
<a class="reference internal" href="#sec-transfer-backdoor-attack"><span class="std std-numref">8.4节</span></a> 和 <a class="reference internal" href="#sec-fl-backdoor"><span class="std std-numref">8.5节</span></a>
分别介绍了针对迁移学习和联邦学习的后门攻击，这些攻击策略都需要根据相应的学习范式对后门触发器进行独特的设计和优化。最后，章节
<a class="reference internal" href="#sec-other-backdoor-attacks"><span class="std std-numref">8.6节</span></a>
介绍了图像分类以外的学习任务和场景下的后门攻击，这些攻击方法需要结合具体的场景作灵活的设计。</p>
</div>
</div>


        </div>
        <div class="side-doc-outline">
            <div class="side-doc-outline--content"> 
<div class="localtoc">
    <p class="caption">
      <span class="caption-text">Table Of Contents</span>
    </p>
    <ul>
<li><a class="reference internal" href="#">8. 模型安全：后门攻击</a><ul>
<li><a class="reference internal" href="#sec-input-space-backdoor">8.1. 输入空间攻击</a></li>
<li><a class="reference internal" href="#sec-model-space-backdoor">8.2. 模型空间攻击</a></li>
<li><a class="reference internal" href="#sec-feature-space-backdoor">8.3. 特征空间攻击</a></li>
<li><a class="reference internal" href="#sec-transfer-backdoor-attack">8.4. 迁移学习攻击</a></li>
<li><a class="reference internal" href="#sec-fl-backdoor">8.5. 联邦学习攻击</a></li>
<li><a class="reference internal" href="#sec-other-backdoor-attacks">8.6. 不同场景下的攻击</a></li>
<li><a class="reference internal" href="#id57">8.7. 本章小结</a></li>
</ul>
</li>
</ul>

</div>
            </div>
        </div>

      <div class="clearer"></div>
    </div><div class="pagenation">
     <a id="button-prev" href="chap7.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="P">
         <i class="pagenation-arrow-L fas fa-arrow-left fa-lg"></i>
         <div class="pagenation-text">
            <span class="pagenation-direction">Previous</span>
            <div>7. 模型安全：对抗防御</div>
         </div>
     </a>
     <a id="button-next" href="chap9.html" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--colored" role="botton" accesskey="N">
         <i class="pagenation-arrow-R fas fa-arrow-right fa-lg"></i>
        <div class="pagenation-text">
            <span class="pagenation-direction">Next</span>
            <div>9. 模型安全：后门防御</div>
        </div>
     </a>
  </div>
        
        </main>
    </div>
  </body>
</html>